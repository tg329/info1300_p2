<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TBD</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <style>
    body {
      margin: 10px;
      align-items: center;
      justify-content: center;
      background-color: #DFE0E2;
    }

    .state {
      fill: none;
    }

    .outline {
      fill: none;
      stroke: black;
      stroke-width: 0.5px;
    }

    .slider {
      display: flex;
      flex-direction: column;
    }

    #yearSlider {
      transform: translateY(100%) rotate(-90deg);
      transform-origin: center;
      width: 400px;
      margin-left: -200px;
      margin-top: -400px;
    }

    #sliderYear {
      position: absolute;
      margin-top: -150px;
      margin-left: -20px;
    }

    #choropleth {
      margin: 0px;
      padding: 0px;
      margin-bottom: -10px;
    }

    .graph1 {
      display: flex;
      flex-direction: column;
    }

    .lineg {
      margin: 0px;
      margin-top: -50px;
    }

    .tooltip {
      pointer-events: none;
      visibility: hidden;
    }

    .tooltip text {
      fill: white;
      text-anchor: middle;
    }

    .main {
      padding: 30px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .title-thing {
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      font-size: 28px;
      background-color: #283845;
      color: #DFE0E2;
      padding: 50px;
      width: 100%;
      margin-bottom: 30px;

    }

    #desc2 {
      font-size: 15px;
      margin-left: 80px;
    }

    h3 {
      color: #B75D69;
      font-size: 20px;
    }

    .map-parent {
      display: flex;
      flex-direction: row;
    }

    .graph-desc {
      padding: 35px;
      border-radius: 15px;
      background-color: #2D898B;
      color: #DFE0E2;
    }

    #choro {
      height: 550px;

    }
  </style>
</head>

<body>
  <!-- Choropleth Map -->

  <div class="title-thing">
    <p class="title-desc">
      viz story title
    </p>
    <p class="title-desc" id="desc2">
      shihan gao, nicole lin (njll), jolly zheng, elaine wu
    </p>
  </div>

  <div class="main">
    <div class="graph1">
      <h3>
        graph 1 title
      </h3>

      <div class="map-parent">
        <div class=" map">

          <svg id="choropleth" height="700" width="1000"></svg>
          <div class="slider">
            <input type="range" id="yearSlider" min="2001" max="2021" step="1" value="2001">
            <span id="sliderYear">2001</span>
          </div>

        </div>

        <div class="graph-desc" id="choro">
          <p>blah blah blah add stuff here. mention on energy produced / population</p>
        </div>
      </div>
    </div>


    <div class="lineg">
      <svg id="line-graph" width="1100" height="300"></svg>
      <svg id="line-legend" width="200" height="400"></svg>

      <h3>
        graph 2 title
      </h3>
      <div class="graph-desc" id="lineg">
        <p>blah blah blah add stuff here mention what MWh means (what we are using to measure)</p>
      </div>
    </div>
  </div>


  <!-- CHOROPLETH -->
  <script>
    const svg = d3.select("#choropleth");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 20, right: 100, bottom: 20, left: 100 };
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
    let energyData = {};
    let populationData = {};

    const requestData = async function () {
      const us = await d3.json("us.json");
      const states = topojson.feature(us, us.objects.states);
      const statesMesh = topojson.mesh(us, us.objects.states);

      const pop = await d3.csv("pop_all_years.csv", d3.autoType);
      const prod = await d3.csv("producer_years.csv", d3.autoType);

      // aggregate population by state and year
      pop.forEach(d => {
        populationData[d.States] = {};
        for (let year = 2000; year <= 2022; year++) {
          populationData[d.States][year] = d[year];
        }
      });

      // aggregate energy gen by state and year
      prod.forEach(d => {
        if (!energyData[d.State]) {
          energyData[d.State] = {};
        }
        if (!energyData[d.State][d.YEAR]) {
          energyData[d.State][d.YEAR] = 0;
        }
        energyData[d.State][d.YEAR] += d['GENERATION (Megawatthours)'];
      });

      const projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], states);
      const path = d3.geoPath().projection(projection);

      const statePaths = map
        .selectAll("path.state")
        .data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("d", path);

      map.append("path")
        .datum(statesMesh)
        .attr("class", "outline")
        .attr("d", path);

      const colorScale = d3.scaleQuantile()
        .domain(energyArray(2001))
        .range(["#084081", "#0868ac", "#43a2ca", "#a8ddb5", "#e0f3f8"]);

      updateMap(2001, colorScale);

      d3.select("#yearSlider").on("input", function () {
        const year = +this.value;
        d3.select("#sliderYear").text(year);
        updateMap(year, colorScale);
      });

      //instructor given code
      const tooltipWidth = 120;
      const tooltipHeight = 40;
      const tooltip = map.append("g")
        .attr("class", "tooltip");

      tooltip.append("rect")
        .attr("x", -tooltipWidth / 2.0)
        .attr("y", 0)
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight);

      const txt = tooltip.append("text")
        .attr("x", 0)
        .attr("y", 2);

      const txt2 = tooltip.append("text")
        .attr("x", 0)
        .attr("y", 22);

      const momesh = map.append("path")
        .attr("class", "mouseover outline")
        .style("stroke", "black")
        .style("stroke-width", 3)
        .attr("d", "");

      statePaths.on("mouseover", function (event, d) {
        const stateName = d.properties.name;
        const year = +document.getElementById("yearSlider").value;
        const energyPerCapita = energyPerState(stateName, year);
        tooltip.style("visibility", "visible");

        txt.text(stateName);
        txt2.text(`${energyPerCapita.toFixed(2)} MWh`);


        const bounds = path.bounds(d);
        const xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
        const yPos = bounds[1][1] - 15;

        tooltip.attr("transform", `translate(${xPos},${yPos})`);

        const stateID = d.id;
        let mo = topojson.mesh(us, us.objects.states, function (a, b) {
          return a.id === stateID || b.id === stateID;
        });
        momesh.datum(mo).attr("d", path);
      });

      statePaths.on("mouseout", function () {
        tooltip.style("visibility", "hidden");
        momesh.attr("d", "");
      });

      // LINE GRAPH CLICK STUFF
      d3.csv("source_years.csv", d3.autoType).then(function (data) {
        energySourceData = data;

        statePaths.on("click", function (event, d) {
          const stateName = d.properties.name;
          const stateEnergyData = energySourceData.filter(d => d.State === stateName);
          const linesvg = d3.select("#line-graph");
          const legendSvg = d3.select("#line-legend");

          linesvg.selectAll("*").remove(); // remove old graph
          legendSvg.selectAll("*").remove(); //remove old legend

          updateLineGraph(stateEnergyData); // add new graph + legend

        });
      });

    };

    // calculate energy per capita for each state per year
    const energyPerState = (state, year) => {
      if (energyData[state] && populationData[state] && populationData[state][year]) {
        return energyData[state][year] / populationData[state][year];
      } else {
        return 0;
      }
    };

    const energyArray = (year) => {
      return Object.keys(populationData).map(state => energyPerState(state, year));
    };

    const updateMap = (year, colorScale) => {
      map.selectAll("path.state").style("fill", d => {
        const energyPerCapita = energyPerState(d.properties.name, year);
        return colorScale(energyPerCapita);
      });
    };

    requestData();
  </script>

  <!-- LINE GRAPH UPDATE -->
  <script>
    const updateLineGraph = (stateData) => {
      const linesvg = d3.select("#line-graph");
      const lwidth = linesvg.attr("width");
      const lheight = linesvg.attr("height");
      const lmargin = { top: 10, right: 10, bottom: 50, left: 50 };
      const graphWidth = lwidth - lmargin.left - lmargin.right;
      const graphHeight = lheight - lmargin.top - lmargin.bottom;

      const annotations = linesvg.append("g").attr("id", "annotations");
      const lineGraph = linesvg.append("g")
        .attr("transform", `translate(${lmargin.left},${lmargin.top})`);

      if (!stateData || stateData.length === 0) {
        linesvg.append("text")
          .attr("x", lwidth / 2)
          .attr("y", lheight / 2)
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("class", "default-message")
          .text("Click on a state to view energy source data");
        return;
      }

      const filtered = stateData.filter(d => d['YEAR'] >= 2001 && d['YEAR'] <= 2021);
      const energySource = d3.group(filtered, d => d['ENERGY SOURCE']);

      // SCALE STUFF
      const yearExtent = d3.extent(filtered, d => d['YEAR']);
      const yearScale = d3.scaleLinear()
        .domain(yearExtent)
        .range([0, graphWidth]);
      const genExtent = d3.extent(filtered, d => d['GENERATION (Megawatthours)']);
      const genScale = d3.scaleLinear()
        .domain(genExtent)
        .range([graphHeight, 0]);

      // AXIS STUFF
      const bottomAxis = d3.axisBottom(yearScale)
        .ticks(24)
        .tickFormat(d3.format("d"));
      const leftAxis = d3.axisLeft(genScale)
        .tickFormat(d3.format("~s"))
        .ticks(10);
      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(${lmargin.left},${graphHeight + lmargin.top})`)
        .call(bottomAxis);
      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", `translate(${lmargin.left},${lmargin.top})`)
        .call(leftAxis);

      // ADDING LINE STUFF
      const lineGen = d3.line()
        .x(d => yearScale(d['YEAR']))
        .y(d => genScale(d['GENERATION (Megawatthours)']))
      // .curve(d3.curveMonotoneX);
      const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
      lineGraph.selectAll(".line")
        .data([...energySource]) // make into an array so line graph works
        .join("path")
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", ([key]) => colorScale(key))
        .attr("stroke-width", 2)
        .attr("d", ([key, values]) => lineGen(values));

      // LABEL STUFF
      linesvg.append("text")
        .attr("x", lwidth / 2)
        .attr("y", lheight - 10)
        .attr("text-anchor", "middle")
        .attr("font-size", "14px")
        .attr("font-weight", "bold")
        .text("Year");

      linesvg.append("text")
        .attr("x", -lheight / 2 + 15)
        .attr("y", 10)
        .attr("transform", "rotate(-90)")
        .attr("text-anchor", "middle")
        .attr("font-size", "14px")
        .attr("font-weight", "bold")
        .text("Energy Generation (MWh)");

      // CIRCLE/SOME MORE INTERACTIVITY STUFF
      const nameMapping = {
        "Hydroelectric Conventional": "Hydroelectric",
        "Wood and Wood Derived Fuels": "Wood",
        "Solar Thermal and Photovoltaic": "Solar/Photovoltaic"
      };


      const circles = lineGraph.selectAll("circle").data(stateData)
        .join("circle")
        .attr("r", 2.5)
        .attr("fill", "navy")
        .attr("cx", d => yearScale(d['YEAR']))
        .attr("cy", d => genScale(d['GENERATION (Megawatthours)']));

      circles.on("mouseover", function (event, d) {
        d3.select(this)
          .attr("r", 5)
          .attr("fill", "orange");

        const x = yearScale(d['YEAR']) + 10;
        const y = genScale(d['GENERATION (Megawatthours)']) - 10; // Position the text above initially

        const textYOffset = y < 20 ? 20 : -10;
        const textXOffset = x > graphWidth - 100 ? -150 : 10;
        const labelText = `${d['ENERGY SOURCE']}: ${d['GENERATION (Megawatthours)']} MWh`;


        // for testing
        // if (x > graphWidth - 20) {
        //   console.log("x is too close to the right, x position:", x);
        // }

        lineGraph.append("text")
          .attr("id", "energy-generation-label")
          .attr("x", x + textXOffset)
          .attr("y", y + textYOffset)
          .attr("font-size", "12px")
          .attr("fill", "black")
          .text(labelText);


      })
        .on("mouseout", function () {
          d3.select(this)
            .attr("r", 2.5)
            .attr("fill", "navy");

          d3.select("#energy-generation-label").remove();
        });


      // LEGEND STUFF
      const legendSvg = d3.select("#line-legend");
      const legendWidth = legendSvg.attr("width");
      const legendHeight = legendSvg.attr("height");
      const legend = legendSvg.append("g")
        .attr("transform", `translate(20, 120)`);

      legend.append("text")
        .attr("x", 0)
        .attr("y", -20)
        .attr("font-size", "14px")
        .attr("font-weight", "bold")
        .text("Energy Sources");

      const sortedKeys = [...energySource.keys()].sort();

      sortedKeys.forEach((key, index) => {
        legend.append("line")
          .attr("x1", 0)
          .attr("y1", index * 20)
          .attr("x2", 20)
          .attr("y2", index * 20)
          .attr("stroke", colorScale(key))
          .attr("stroke-width", 2);

        legend.append("text")
          .attr("x", 30)
          .attr("y", index * 20 + 5)
          .text(nameMapping[key] || key)
          .attr("text-anchor", "start")
          .style("alignment-baseline", "middle");
      });


    };

    updateLineGraph([]);
  </script>

</body>

</html>